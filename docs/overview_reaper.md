+++
title = "官方中文文档 openstack swift overview reaper"
date = 2019-01-21T00:00:00-08:00
lastmod = 2019-01-23T23:20:40-08:00
tags = ["swift", "transilation"]
categories = ["swift"]
draft = false
weight = 3001
+++

<https://docs.openstack.org/swift/queens/overview%5Freaper.html>

账户收割者

更新时间：2019-01-15 02:30

帐户收割者在后台删除已删除帐户中的数据。

如果reseller在帐户的存储URL上发出DELETE请求，则会将帐户标记为删除。这只是将
DELETED值放入帐户数据库（和副本）account\_stat表的状态列中，说明稍后应删除该帐户的数据。

通常没有设定的保留时间且没有取消删除; 假设reseller将实施此类功能，并且只有在真正希望删除帐户的数据时才在帐户上调用DELETE。但是，为了保护Swift群集帐户免受不正确或错误删除请求的影响，您可以在account-server.conf的[account-reaper]部分设置delay\_reaping值，以延迟实际删除数据。目前，取消删除帐户没有任何效用; 必须直接更新帐户数据库副本，将status列设置为空字符串并将put\_timestamp更新为大于delete\_timestamp。（在TODO列表上正在编写一个实用程序来执行此任务，最好是通过REST调用。）

帐户收割机在每个帐户服务器上运行，并偶尔扫描服务器以查找标记为删除的帐户数据库。它只会在服务器是主节点的帐户上触发，因此多个帐户服务器并非都在尝试同时执行相同的工作。使用多个服务器删除一个帐户可能会提高删除速度，但需要协调，因此不会重复工作。速度确实不是数据删除所关注的问题，并且通常不会删除大型帐户。

帐户本身的删除过程非常简单。对于帐户中的每个容器，将删除每个对象，然后删除容器。
任何失败的删除请求都不会停止整个过程，但会导致整个过程最终失败（例如，如果对象删
除超时，则以后无法删除容器，因此帐户也无法删除）。整个过程即使在发生故障时也会继
续，因此不会因为一个麻烦的地点而无法收回集群空间。帐户收割者将继续尝试删除帐户，
直到它最终变为空，此时db\_replicator中的数据库回收进程最终将删除数据库文件。

有时，持久性错误状态可能会阻止某些对象或容器被删除。如果发生这种情况，您将在日志中看到诸如“Account <name> has not been reaped since <date>”的消息。您可以使用account-server.conf文件的[account-reaper]部分中的reap\_warn\_after值来控制何时记录此值。默认情况下，是30天。


## 历史 {#历史}

首先，考虑通过完全外部调用删除帐户的简单方法，因为它不需要对系统进行任何更改。所有数据都将通过公共REST API以与实际用户相同的方式删除。但是，缺点是它会使用代理资源并在不需要时记录所有内容。此外，它可能需要一个或两个专用服务器，仅用于发出删除请求。

还考虑了一种完全自下而上的方法，其中对象和容器服务器偶尔会扫描它们所持有的数据并
检查帐户是否被删除，如果是，则删除数据。好处是回收的速度，对代理或日志记录没有影
响，但缺点是几乎100％的扫描都会导致无缘无故地创建大量I/O负载。

还考虑了更多以容器服务器为中心的方法，其中帐户服务器将所有容器标记为删除，容器服
务器将删除每个容器中的对象然后删除自己。这对于拥有大量容器的帐户仍然可以快速回收，
但具有相当大的负载峰值的缺点。可以减慢这个过程以减轻负载峰值的可能性，但是就会失
去快速回收的好处，而剩下的只是一个更复杂的过程。此外，扫描所有容器以查找标记为删
除的容器，而大多数容器似乎不会浪费。db\_replicator可以在执行复制扫描时执行此操作，
但它必须生成并跟踪看起来不必要复杂的删除过程。

最后，如上所述，以帐户服务器为中心的方法似乎是最好的。
